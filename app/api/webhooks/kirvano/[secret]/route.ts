import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import bcrypt from 'bcryptjs'
import { generateSecurePassword, sendWelcomeEmail, sendSubscriptionCanceledEmail, sendGenericNoticeEmail } from '@/lib/email'
import { getBrazilNow } from '@/lib/timezone'

// Tipos para os eventos da Kirvano (estrutura oficial)
interface KirvanoWebhookEvent {
  event: string // 'SALE_APPROVED' | outros eventos futuros
  customer: {
    email: string
    name: string
    id?: string
  }
  plan: {
    name: string
    id?: string
    next_charge_date?: string
  }
  sale_id?: string
  subscription_id?: string
  created_at?: string
  [key: string]: any // Para outros campos que possam vir
}

// Fun√ß√£o para mapear planos da Kirvano para nosso sistema
function mapKirvanoPlanName(kirvanoPlanName: string): string {
  const normalizedName = kirvanoPlanName.toLowerCase().trim()
  
  // Mapeamento baseado no nome exato do plano da Kirvano
  if (normalizedName.includes('ultra')) {
    return 'ULTRA'
  }
  if (normalizedName.includes('premium')) {
    return 'PREMIUM'
  }
  if (normalizedName.includes('b√°sico') || normalizedName.includes('basico')) {
    return 'BASIC'
  }
  if (normalizedName.includes('free') || normalizedName.includes('gratuito')) {
    return 'FREE'
  }
  
  // Padr√£o: se n√£o conseguir identificar, assumir BASIC
  console.warn(`‚ö†Ô∏è Plano n√£o reconhecido: "${kirvanoPlanName}", usando BASIC como padr√£o`)
  return 'BASIC'
}

// Detecta ciclo (mensal/anual) baseado no nome do plano vindo da Kirvano
function detectPlanCycle(kirvanoPlanName: string): 'MONTHLY' | 'ANNUAL' {
  const normalizedName = kirvanoPlanName.toLowerCase()
  if (normalizedName.includes('anual') || normalizedName.includes('annual') || normalizedName.includes('12 meses')) {
    return 'ANNUAL'
  }
  return 'MONTHLY'
}

// Normaliza uma data para 23:59:59.999 (fim do dia) no fuso de S√£o Paulo garantindo acesso at√© o final do dia.
function normalizeToBrazilEndOfDay(date: Date): Date {
  const clone = new Date(date)
  // Garantir corre√ß√£o de fuso capturando data no timezone BR (caso servidor esteja em UTC)
  const brazilRef = new Date(getBrazilNow().toLocaleString('sv-SE', { timeZone: 'America/Sao_Paulo' }))
  // Mantemos apenas Y/M/D do par√¢metro original e setamos para 23:59:59.999
  clone.setHours(23,59,59,999)
  return clone
}

export async function POST(request: NextRequest, { params }: { params: { secret: string } }) {
  const secretFromUrl = params.secret;
  const expectedSecret = process.env.KIRVANO_WEBHOOK_SECRET_PATH;

  // Valida√ß√£o de seguran√ßa da URL
  if (!secretFromUrl || secretFromUrl !== expectedSecret) {
    console.warn(`üö® Tentativa de acesso ao webhook com chave secreta inv√°lida: [${secretFromUrl}]`);
    console.warn(`üîë Chave esperada: [${expectedSecret}]`);
    return NextResponse.json(
      { error: "Unauthorized" }, 
      { status: 401 }
    );
  }

  console.log("‚úÖ Chave secreta do webhook validada com sucesso.");
  console.log("üöÄ --- NOVO WEBHOOK RECEBIDO DA KIRVANO (Valida√ß√£o por URL ativa) ---");

  try {
    // 1. Ler e processar o corpo da requisi√ß√£o
    let webhookData: KirvanoWebhookEvent
    try {
      webhookData = await request.json()
    } catch (error) {
      console.error('‚ùå Erro ao parsear JSON do webhook:', error)
      return NextResponse.json(
        { error: 'Invalid JSON payload' },
        { status: 400 }
      )
    }

    console.log("üì± Webhook data recebido:", JSON.stringify(webhookData, null, 2));

    // Processar eventos da Kirvano
    switch (webhookData.event) {
      case 'SALE_APPROVED':
        await handleSaleApproved(webhookData)
        break

      case 'SUBSCRIPTION_CANCELED':
      case 'SUBSCRIPTION_EXPIRED':
        await handleSubscriptionCanceledOrExpired(webhookData)
        break

      case 'SUBSCRIPTION_RENEWED':
        await handleSubscriptionRenewed(webhookData)
        break

      // Eventos de reembolso (nomes potenciais) ‚Äì ajustar se documenta√ß√£o oficial diferir
      case 'SALE_REFUNDED':
      case 'REFUND':
      case 'SALE_REFUND':
        await handleSubscriptionRefunded(webhookData)
        break

      default:
        console.log(`‚ö†Ô∏è Webhook recebido, mas o evento '${webhookData.event}' n√£o √© tratado por esta parte do c√≥digo.`)
        break
    }

    // Sempre retornar sucesso para a Kirvano
    return NextResponse.json(
      { 
        message: 'Webhook recebido',
        event: webhookData.event
      },
      { status: 200 }
    )

  } catch (error) {
    console.error('‚ùå Erro interno ao processar webhook da Kirvano:', error)
    
    // Mesmo com erro interno, retornamos 200 para n√£o ficar reprocessando
    return NextResponse.json(
      { 
        message: 'Webhook received but processing failed',
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 200 }
    )
  }
}

// Fun√ß√£o principal para processar SALE_APPROVED (Find or Create)
async function handleSaleApproved(webhookData: KirvanoWebhookEvent) {
  try {
    console.log(`üîî Processando SALE_APPROVED da Kirvano`)
    
    // 1. Extrair dados do webhook
    const customerEmail = webhookData.customer.email
    const customerName = webhookData.customer.name
    const planName = webhookData.plan.name
    const subscriptionEndDate = webhookData.plan.next_charge_date
    const kirvanoSubscriptionId = webhookData.subscription_id || webhookData.sale_id
    
    console.log(`üìß Cliente: ${customerName} (${customerEmail})`)
    console.log(`üíé Plano: ${planName}`)
    console.log(`üìÖ Pr√≥xima cobran√ßa: ${subscriptionEndDate}`)
    
    // 2. Implementar l√≥gica "Find or Create"
    let tenant = await prisma.tenant.findUnique({
      where: {
        email: customerEmail
      }
    })
    
    if (tenant) {
      // TENANT EXISTENTE: Atualizar dados da assinatura
      console.log(`üë§ Tenant existente encontrado: ${tenant.id}`)
      
      // ‚úÖ CORRIGIDO: Extrair o nome do plano DIRETAMENTE do webhook
      const planNameFromKirvano = webhookData.plan.name
  const mappedPlan = mapKirvanoPlanName(planNameFromKirvano)
  const planCycle = detectPlanCycle(planNameFromKirvano)
      
      console.log(`üìù Nome do plano da Kirvano: "${planNameFromKirvano}"`)
      console.log(`üìù Plano mapeado para o sistema: "${mappedPlan}"`)
      
      let subscriptionEnd: Date | undefined
      if (subscriptionEndDate) {
        subscriptionEnd = normalizeToBrazilEndOfDay(new Date(subscriptionEndDate))
      } else {
        subscriptionEnd = new Date()
        subscriptionEnd.setMonth(subscriptionEnd.getMonth() + 1)
        subscriptionEnd = normalizeToBrazilEndOfDay(subscriptionEnd)
      }
      
  const updateData = {
        isActive: true,
        businessPlan: mappedPlan, // ‚úÖ USAR A VARI√ÅVEL AQUI
        subscriptionEnd,
        updatedAt: new Date(),
        planCycle
      }
      
  if (kirvanoSubscriptionId) (updateData as any).kirvanoSubscriptionId = kirvanoSubscriptionId
      
  await prisma.tenant.update({
        where: { id: tenant.id },
        data: {
          ...updateData,
          // webhookExpiredProcessed: false, // descomentar ap√≥s prisma generate se campo existir
          lastSubscriptionEmailType: 'WELCOME'
        }
      })
      
      console.log(`‚úÖ Assinatura atualizada para tenant existente ${tenant.id} - Plano: ${mappedPlan}`)
      
    } else {
      // TENANT NOVO: Criar com onboarding completo
      console.log(`üÜï Criando novo tenant para email: ${customerEmail}`)
      
      // 1. Gerar senha segura
      const temporaryPassword = generateSecurePassword(12)
      
      // 2. Fazer hash da senha
      const hashedPassword = await bcrypt.hash(temporaryPassword, 12)
      
      // 3. Determinar plano - ‚úÖ CORRIGIDO: Extrair o nome do plano DIRETAMENTE do webhook
      const planNameFromKirvano = webhookData.plan.name
  const mappedPlan = mapKirvanoPlanName(planNameFromKirvano)
  const planCycle = detectPlanCycle(planNameFromKirvano)
      
      console.log(`üìù Nome do plano da Kirvano: "${planNameFromKirvano}"`)
      console.log(`üìù Plano mapeado para o sistema: "${mappedPlan}"`)
      
      // 4. Calcular data de expira√ß√£o
      let subscriptionEnd: Date = new Date()
      if (subscriptionEndDate) {
        subscriptionEnd = normalizeToBrazilEndOfDay(new Date(subscriptionEndDate))
      } else {
        // Padr√£o: 1 m√™s a partir de agora
        subscriptionEnd.setMonth(subscriptionEnd.getMonth() + 1)
        subscriptionEnd = normalizeToBrazilEndOfDay(subscriptionEnd)
      }
      
      // 5. Criar novo tenant no banco
  const tenantData = {
        name: customerName || customerEmail.split('@')[0],
        email: customerEmail,
        password: hashedPassword,
        isActive: true,
        businessPlan: mappedPlan, // ‚úÖ USAR A VARI√ÅVEL AQUI
        subscriptionEnd,
        planCycle,
        // Configura√ß√µes padr√£o para novo neg√≥cio
        businessName: customerName || 'Meu Neg√≥cio',
        businessPhone: '',
        businessAddress: '',
        businessLogo: null,
      } as any
      
      // Adicionar ID da assinatura da Kirvano se dispon√≠vel
  if (kirvanoSubscriptionId) (tenantData as any).kirvanoSubscriptionId = kirvanoSubscriptionId
  if (webhookData.customer.id) (tenantData as any).kirvanoCustomerId = webhookData.customer.id
      
      const newTenant = await prisma.tenant.create({
        data: {
          ...tenantData,
          lastSubscriptionEmailType: 'WELCOME'
        }
      })
      
      console.log(`‚úÖ Novo tenant criado com ID: ${newTenant.id}`)
      
      // 6. Enviar email de boas-vindas com credenciais
      try {
        const emailSent = await sendWelcomeEmail(
          newTenant.name,
            newTenant.email,
            temporaryPassword,
            mappedPlan,
            subscriptionEnd
          )
        
        if (emailSent) {
          console.log(`‚úÖ Email de boas-vindas enviado para: ${newTenant.email}`)
        } else {
          console.error(`‚ùå Falha ao enviar email de boas-vindas para: ${newTenant.email}`)
        }
      } catch (emailError) {
        console.error('‚ùå Erro ao enviar email de boas-vindas:', emailError)
        // Continua sem falhar, pois o tenant j√° foi criado
      }
      
      console.log(`üéâ Onboarding autom√°tico conclu√≠do para tenant: ${newTenant.email}`)
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao processar SALE_APPROVED:', error)
    throw error
  }
}

// Fun√ß√£o para processar SUBSCRIPTION_CANCELED e SUBSCRIPTION_EXPIRED
async function handleSubscriptionCanceledOrExpired(webhookData: KirvanoWebhookEvent) {
  try {
    const eventType = webhookData.event
    console.log(`üö´ Processando ${eventType} da Kirvano`)
    
    // 1. Extrair email do cliente
    const customerEmail = webhookData.customer.email
    console.log(`üìß Cancelando/Expirando assinatura para: ${customerEmail}`)
    
    // 2. Encontrar o tenant correspondente
    const tenant = await prisma.tenant.findUnique({
      where: {
        email: customerEmail
      }
    })
    
    if (!tenant) {
      console.error(`‚ùå Tenant n√£o encontrado para email: ${customerEmail}`)
      return
    }
    
    // 3. Atualizar o tenant para desativar a assinatura
  await prisma.tenant.update({
      where: { id: tenant.id },
      data: {
        isActive: false,
  updatedAt: new Date(),
  // webhookExpiredProcessed: true,
  lastSubscriptionEmailType: eventType === 'SUBSCRIPTION_EXPIRED' ? 'EXPIRED_WEBHOOK' : 'CANCELED'
      }
    })
    try {
      await sendSubscriptionCanceledEmail(tenant.name || tenant.email, tenant.email, tenant.businessPlan)
    } catch (e) {
      console.error('‚úâÔ∏è Erro ao enviar email de cancelamento:', e)
    }
    
    console.log(`‚úÖ Assinatura ${eventType.toLowerCase()} para tenant ${tenant.id} - Marcado inativo (sem downgrade para FREE)`) 
    
  } catch (error) {
    console.error(`‚ùå Erro ao processar ${webhookData.event}:`, error)
    throw error
  }
}

// Fun√ß√£o para processar SUBSCRIPTION_RENEWED
async function handleSubscriptionRenewed(webhookData: KirvanoWebhookEvent) {
  try {
    console.log(`üîÑ Processando SUBSCRIPTION_RENEWED da Kirvano`)
    
    // 1. Extrair dados do webhook
    const customerEmail = webhookData.customer.email
    const newExpirationDate = webhookData.plan.next_charge_date
    
    console.log(`üìß Renovando assinatura para: ${customerEmail}`)
    console.log(`üìÖ Nova data de expira√ß√£o: ${newExpirationDate}`)
    
    // 2. Encontrar o tenant correspondente
    const tenant = await prisma.tenant.findUnique({
      where: {
        email: customerEmail
      }
    })
    
    if (!tenant) {
      console.error(`‚ùå Tenant n√£o encontrado para email: ${customerEmail}`)
      return
    }
    
    // 3. Atualizar a data de expira√ß√£o
    let subscriptionEnd: Date | undefined
    if (newExpirationDate) {
      subscriptionEnd = normalizeToBrazilEndOfDay(new Date(newExpirationDate))
    } else {
      subscriptionEnd = new Date()
      subscriptionEnd.setMonth(subscriptionEnd.getMonth() + 1)
      subscriptionEnd = normalizeToBrazilEndOfDay(subscriptionEnd)
    }
    
  await prisma.tenant.update({
      where: { id: tenant.id },
      data: {
        isActive: true, // Garantir que est√° ativo
        subscriptionEnd,
  updatedAt: new Date(),
  // webhookExpiredProcessed: false,
  lastSubscriptionEmailType: 'RENEWED'
      }
    })
    
    console.log(`‚úÖ Assinatura renovada para tenant ${tenant.id} at√© ${subscriptionEnd.toISOString()}`)
    
  } catch (error) {
    console.error('‚ùå Erro ao processar SUBSCRIPTION_RENEWED:', error)
    throw error
  }
}

// Fun√ß√£o para processar reembolso de venda/assinatura
async function handleSubscriptionRefunded(webhookData: KirvanoWebhookEvent) {
  try {
    console.log('üí∏ Processando evento de reembolso (refund) da Kirvano')
    const customerEmail = webhookData.customer?.email
    if (!customerEmail) {
      console.error('‚ùå Webhook de reembolso sem email de cliente')
      return
    }

    const tenant = await prisma.tenant.findUnique({ where: { email: customerEmail } })
    if (!tenant) {
      console.warn(`‚ö†Ô∏è Tenant n√£o encontrado para reembolso: ${customerEmail}`)
      return
    }

    const now = new Date()
    const updated = await prisma.tenant.update({
      where: { id: tenant.id },
      data: {
        isActive: false,
        businessPlan: 'Reembolsado', // Marca claramente o motivo
        subscriptionEnd: now,
        updatedAt: now,
        // Opcional: poder√≠amos marcar lastSubscriptionEmailType como 'CANCELED' para reutilizar enum existente
        lastSubscriptionEmailType: 'CANCELED'
        // webhookExpiredProcessed deixado de fora (n√£o √© expira√ß√£o, √© reembolso)
      }
    })

    console.log(`‚úÖ Reembolso processado: tenant ${tenant.id} (${customerEmail}) desativado.`)

    // Enviar email de notifica√ß√£o de reembolso
    try {
      const portalUrl = `${process.env.NEXTAUTH_URL || 'https://tymerbook.com'}/dashboard/assinatura`
      await sendGenericNoticeEmail({
        email: tenant.email,
        name: tenant.name || tenant.email,
        plan: tenant.businessPlan,
        subject: 'üí∏ Reembolso processado',
        title: 'Reembolso Confirmado',
        subtitle: 'Acesso desativado',
        body: `<p>Ol√° <strong>${tenant.name || tenant.email}</strong>,</p><p>O reembolso da sua assinatura foi processado e o acesso foi desativado.</p><p>Se desejar voltar, voc√™ pode reativar uma nova assinatura quando quiser.</p>`,
        ctaText: 'Gerenciar Assinatura',
        ctaUrl: portalUrl
      })
    } catch (emailErr) {
      console.error('‚úâÔ∏è Erro ao enviar email de reembolso:', emailErr)
    }
  } catch (error) {
    console.error('‚ùå Erro ao processar reembolso:', error)
    throw error
  }
}

// M√©todo GET para verificar se o endpoint est√° funcionando
export async function GET() {
  return NextResponse.json({
    message: 'Kirvano Webhook Endpoint - Ready (SALE_APPROVED + Lifecycle)',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    supported_events: [
      'SALE_APPROVED',
      'SUBSCRIPTION_CANCELED', 
      'SUBSCRIPTION_EXPIRED',
      'SUBSCRIPTION_RENEWED'
    ]
  })
}
